<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=620px,user-scalable=no">
<title></title>
<script src="http://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.4.0/fabric.min.js"></script>
<style>
#c {
   border: 1px solid black;
}
#count {
  font-weight: bold;
  margin-left: 2em;
}
</style>
</head>
<body>
<h1>Flappy Ball</h1>
<p id="count">0</p>
<div>
  <canvas id="c"></canvas>
</div>
<script>
var util = {
      isSmartphone: function(){
        return navigator.userAgent.indexOf('iPhone') > 0 ||
               navigator.userAgent.indexOf('iPad') > 0 ||
               navigator.userAgent.indexOf('iPod') > 0 ||
               navigator.userAgent.indexOf('Android') > 0;
      },
      linear: function(t, b, c, d) { return c*t/d + b; },
    },
    consts = {
      canvasElementId : "c",
      canvasHeight    : 300,
      canvasWidth     : 600,
      canvasColor     : '#88c6e4',
      gameoverColor   : '#000',
      ballRx          : 13,
      ballRy          : 10,
      ballLeft        : 100,
      ballTop         : 100,
      ballColor       : 'red',
      ballFallDuration: 700,
      ballFlapDuration: 200,
      blockWidth      : 80,
      blockColors     : ['#b25424', '#ac613c', '#cc9528', '#7a6334', '#612406'],
      blockDuration   : 6000
    },
    state = null,
    passCount = 0,
    canvas = (function(){
      var c = new fabric.Canvas(consts.canvasElementId);
      c.setWidth(consts.canvasWidth);
      c.setHeight(consts.canvasHeight);
      c.setBackgroundColor(consts.canvasColor, c.renderAll.bind(c));
      return c;
    }());
    ball = null,
    blocks = [],
    factory = (function(){
      var createBall = function(){
            var result = new fabric.Ellipse({
                  top: consts.ballTop,
                  left: consts.ballLeft,
                  fill: consts.ballColor,
                  strokeWidth: 0,
                  rx: consts.ballRx,
                  ry: consts.ballRy
                });
            result.flapFlag = false;
            result.fallFlag = false;
            result.fall = function(){
              if (this.fallFlag) return;
              var that = this;
              that.fallFlag = true;
              that.animate('top', canvas.getHeight(), {
                duration: consts.ballFallDuration,
                onChange: function(){
                  that.setCoords();
                  ballBottom = that.get('top') + that.get('ry');
                  if (ballBottom >= canvas.getHeight()) state = 'playEnd';
                  else                     canvas.renderAll();
                },
                onComplete: function(){ that.fallFlag = false; },
                easing: fabric.util.easeInCirc,
                abort: function(){ return that.flapFlag || state !== 'play'; }
              });
              that.animate('angle', 60, {
                easing: fabric.util.easeInCirc,
                abort: function(){ return that.flapFlag || state !== 'play'; }
              });
            };
            result.flap = function(){
              if (this.flapFlag) return;
              var that = this,
                  flapValue = canvas.getHeight() / 30 * 4;
              that.flapFlag = true;
              that.set('angle', 0);
              that.animate('top', '-=' + flapValue, {
                duration: consts.ballFlapDuration,
                onChange: function(){
                  that.setCoords();
                  canvas.renderAll();
                },
                onComplete: function(){ that.flapFlag = false; },
                easing: util.linear
              });
            };
            return result;
          },
          createBlock = function(top_position, height, color, showedCallback, overshotCallback){
            var blockWidth = consts.blockWidth,
                result = new fabric.Rect({
                  left:        canvas.getWidth() + 200,
                  top:         top_position,
                  fill:        color,
                  strokeWidth: 0,
                  width:       blockWidth,
                  height:      height,
                  selectable:  false
                });
            result.isShow = false;
            result.isPassed = false;
            result.on('added', function(fn){
              var that = this;
              that.animate('left', -blockWidth, {
                duration: consts.blockDuration,
                onChange: function(){
                  that.setCoords();
                  if (state === 'play' && !that.isShow && that.left <= canvas.getWidth() - blockWidth) {
                    that.isShow = true;
                    if (typeof showedCallback === 'function') showedCallback();
                  }
                  if (!that.isPassed && (that.left + that.width) <= ball.left) {
                    that.isPassed = true;
                    if (typeof overshotCallback === 'function') overshotCallback();
                  }
                  if (that.intersectsWithObject(ball)) state = 'playEnd';
                },
                onComplete: function(){ if (that.left + that.width < 0) that.remove(); },
                easing: util.linear,
                abort: function(){ return state !== 'play'; }
              });
            });
            return result;
          };
      return {
        createBall: createBall,
        createBlock: createBlock
      }
    }()),
    game = {
      addBarricade: function(){
        var blockSplitCount    = 10,
            spaceBoxCount      = 3,
            boxHeight          = Math.floor(canvas.getHeight() / blockSplitCount),
            floorBlockBoxCount = Math.floor(Math.random() * (blockSplitCount - spaceBoxCount - 1) + 1),
            floorBlockTop      = (blockSplitCount - floorBlockBoxCount) * boxHeight,
            floorBlockHeight   = boxHeight * floorBlockBoxCount,
            roofBlockBoxCount  = blockSplitCount - spaceBoxCount - floorBlockBoxCount,
            roofBlockTop       = -10000,
            roofBlockHeight    = 10000 + boxHeight * roofBlockBoxCount;
            blockColor = (function(){
              var n = Math.floor(Math.random() * consts.blockColors.length);
              return consts.blockColors[n];
            }()),
            showedCallback   = function(){ game.addBarricade(); },
            overshotCallback = function() { passCount++; };
            roofBlock  = factory.createBlock(roofBlockTop, roofBlockHeight, blockColor, showedCallback, overshotCallback),
            floorBlock = factory.createBlock(floorBlockTop, floorBlockHeight, blockColor);
        blocks.push(roofBlock);
        blocks.push(floorBlock);
        canvas.add(roofBlock);
        canvas.add(floorBlock);
      },
      start: function(){
        state = 'play';
      },
      gameover: function(){
        var canvasOrigColor = canvas.backgroundColor;
        state = 'gameover';
        canvas.setBackgroundColor(consts.gameoverColor, function(){
          canvas.renderAll();
          ball.bringToFront();
          ball.animate('top', canvas.getHeight(), {
            onChange: function(){ canvas.renderAll(); },
            onComplete: function(){
              canvas.setBackgroundColor(canvasOrigColor, canvas.renderAll.bind(canvas));
              alert('GAME OVER!!!');
              state = 'gameoverEnd'
            }
          });
        });
        ball.animate('angle', 80, {onChange: canvas.renderAll.bind(canvas)});
      },
      ready: function(){
        state = 'ready';
        canvas.clear();
        if (ball) ball.remove();
        for (var i=0,l=blocks.length; i<l; i++) {
          blocks[i].remove();
        }
        passCount = 0;
        state = 'readyEnd';
        ball = factory.createBall();
        canvas.add(ball);
      },
      initialize: function(){
        canvas.on('mouse:down', function(options) {
          if (util.isSmartphone() && options.e.type !== "touchstart") return;
          if (state === 'readyEnd') {
            game.start();
            game.addBarricade();
          } else if (state === 'play') {
            ball.flap();
          }
        });
        setInterval(function(){
          if (state === 'gameoverEnd')  game.ready();
          else if (state === 'play')    ball.fall();
          else if (state === 'playEnd') game.gameover();
          document.getElementById('count').firstChild.nodeValue = passCount;
        }, 10);
        game.ready();
      }
    }
    ;
game.initialize();
</script>
</body>
</html>
